<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Aoike青池</title>

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://aoike.azurice.com/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<!--<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>-->

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Service.md
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        修改于 · 2021-01-19 10:10:21 · 发布于 · 2021-09-23 07:17:06
                    </time>
                </div>
                <div class="post-content">
                    <h1>Android —— Service</h1>
<h2>〇、Service 的概念</h2>
<p><em>Service</em> 是一种可在后台执行长时间运行操作而不提供界面的应用组件。</p>
<p>可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。</p>
<p>此外，组件可通过绑定到服务与之进行交互，甚至是执行进程间通信 (IPC)。</p>
<blockquote>
<p>处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序进行交互。</p>
</blockquote>
<p>以下是三种不同的服务类型：</p>
<ul>
<li>
<p>前台</p>
<p>执行用户会直接注意到的操作。</p>
<p>前台服务必须显示 <em>通知</em>。即使用户停止与应用的交互，前台服务仍会继续运行。</p>
</li>
<li>
<p>后台</p>
<p>执行用户不会直接注意到的操作。</p>
</li>
<li>
<p>绑定</p>
<p><em>当应用组件通过调用 <code><span class="hljs-function"><span class="hljs-title">bindService</span><span class="hljs-params">()</span></span></code> 绑定到服务时，服务即处于</em>绑定<em>状态。绑定服务会提供客户端-服务器接口，以便组件与服务进行交互、发送请求、接收结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</em></p>
</li>
</ul>
<p><em>无论服务是处于启动状态还是绑定状态（或同时处于这两种状态），任何应用组件均可像使用 Activity 那样，通过调用 <code><span class="hljs-attribute">Intent</span></code> 来使用服务（即使此服务来自另一应用）。不过，您可以通过清单文件将服务声明为私有服务，并阻止其他应用访问该服务。<a href="https://developer.android.google.cn/guide/components/services#Declaring">使用清单文件声明服务</a>部分将对此做更详尽的阐述。</em></p>
<h2>一、基础知识</h2>
<p>要创建服务，必须创建（或使用现有的） <code><span class="hljs-attribute">Service</span></code> 的子类。</p>
<p>应重写的一些最重要的回调方法：</p>
<ul>
<li>
<p><code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code></p>
<p><strong>当另一个组件（如 Activity）请求启动服务时，系统会通过调用 <code><span class="hljs-function"><span class="hljs-title">startService</span><span class="hljs-params">()</span></span></code> 来调用此方法。</strong></p>
<p>执行此方法时，服务即会启动并可在后台无限期运行。</p>
<p>实现此方法后，应在服务工作完成后，负责调用 <code><span class="hljs-function"><span class="hljs-title">stopSelf</span><span class="hljs-params">()</span></span></code> 或 <code><span class="hljs-function"><span class="hljs-title">stopService</span><span class="hljs-params">()</span></span></code> 来停止服务。</p>
</li>
<li>
<p><code><span class="hljs-function"><span class="hljs-title">onBind</span><span class="hljs-params">()</span></span></code></p>
<p><strong>当另一个组件想要与服务绑定（例如执行 RPC）时，系统会通过调用 <code><span class="hljs-function"><span class="hljs-title">bindService</span><span class="hljs-params">()</span></span></code> 来调用此方法。</strong></p>
<p>必须通过返回 <code><span class="hljs-attribute">IBinder</span></code> 提供一个接口，以供客户端用来与服务进行通信。</p>
<p>如果并不希望允许绑定，则应返回 null。</p>
</li>
<li>
<p><code><span class="hljs-function"><span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span></code></p>
<p><strong>首次创建服务时，系统会（在调用 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 或 <code><span class="hljs-function"><span class="hljs-title">onBind</span><span class="hljs-params">()</span></span></code> 之前）调用此方法来执行一次性设置程序。</strong></p>
<p>如果服务已在运行，则不会调用此方法。</p>
</li>
<li>
<p><code><span class="hljs-function"><span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span></code></p>
<p><strong>当不再使用服务且准备将其销毁时，系统会调用此方法。</strong></p>
<p>服务应通过实现此方法来清理任何资源，如线程、注册的侦听器、接收器等。</p>
<p>这是服务接收的最后一个调用。</p>
</li>
</ul>
<p><em>如果组件通过调用 <code><span class="hljs-function"><span class="hljs-title">startService</span><span class="hljs-params">()</span></span></code> 启动服务（这会引起对 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 的调用），则服务会一直运行，直到其使用 <code><span class="hljs-function"><span class="hljs-title">stopSelf</span><span class="hljs-params">()</span></span></code> 自行停止运行，或由其他组件通过调用 <code><span class="hljs-function"><span class="hljs-title">stopService</span><span class="hljs-params">()</span></span></code> 将其停止为止。</em></p>
<p><em>只有在内存过低且必须回收系统资源以供拥有用户焦点的 Activity 使用时，Android 系统才会停止服务。如果将服务绑定到拥有用户焦点的 Activity，则它其不太可能会终止；如果将服务声明为<a href="https://developer.android.google.cn/guide/components/services#Foreground">在前台运行</a>，则其几乎永远不会终止。如果服务已启动并长时间运行，则系统逐渐降低其在后台任务列表中的位置，而服务被终止的概率也会大幅提升—如果服务是启动服务，则您必须将其设计为能够妥善处理系统执行的重启。如果系统终止服务，则其会在资源可用时立即重启服务，但这还取决于您从 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 返回的值。</em></p>
<h2>二、使用清单文件声明服务</h2>
<p>添加 <code><span class="hljs-section">&lt;service&gt;</span></code> 元素作为 <code><span class="hljs-section">&lt;application&gt;</span></code> 元素的子元素：</p>
<pre><code class="hljs language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span> &gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span> &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ExampleService&quot;</span> /&gt;</span>
      ...
  <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<p>您还可在 <code><span class="hljs-section">&lt;service&gt;</span></code> 元素中加入其他属性，以定义一些特性，如启动服务及其运行时所在进程需要的权限。</p>
<p><code>android:<span class="hljs-built_in">name</span></code> 属性是唯一必需的属性，用于指定服务的类名。发布应用后，请保此类名不变，以避免因依赖显式 Intent 来启动或绑定服务而破坏代码的风险（请阅读博文 <a href="http://android-developers.blogspot.com/2011/06/things-that-cannot-change.html">Things That Cannot Change</a> [不能更改的内容]）。</p>
<p>可以通过添加 <a href="https://developer.android.google.cn/guide/topics/manifest/service-element#exported"><code><span class="hljs-symbol">android:</span>exported</code></a> 属性并将其设置为 <code><span class="hljs-literal">false</span></code>，确保服务仅适用于您的应用。这可以有效阻止其他应用启动您的服务，即便在使用显式 Intent 时也如此。</p>
<h2>三、创建启动服务</h2>
<p>启动服务由另一个组件通过调用 <code><span class="hljs-function"><span class="hljs-title">startService</span><span class="hljs-params">()</span></span></code> 启动，这会导致调用服务的 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 方法。</p>
<p><strong>服务启动后，其生命周期即独立于启动它的组件。</strong></p>
<p>应用组件（如 Activity）可通过调用 <code><span class="hljs-function"><span class="hljs-title">startService</span><span class="hljs-params">()</span></span></code> 方法并传递 <code><span class="hljs-attribute">Intent</span></code> 对象（指定服务并包含待使用服务的所有数据）来启动服务。服务会在 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 方法接收此 <code><span class="hljs-attribute">Intent</span></code>。</p>
<p>例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同服务，并通过向 <code><span class="hljs-function"><span class="hljs-title">startService</span><span class="hljs-params">()</span></span></code> 传递一个 Intent，为该服务提供要保存的数据。服务会通过 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 接收 Intent，连接到互联网并执行数据库事务。事务完成后，服务将自行停止并销毁。</p>
<p>通常，您可以扩展两个类来创建启动服务：</p>
<ul>
<li>
<p><code><span class="hljs-attribute">Service</span></code></p>
<p>这是适用于所有服务的基类。</p>
<p>扩展此类时，您必须创建用于执行所有服务工作的新线程，因为服务默认使用应用的主线程，这会降低应用正在运行的任何 Activity 的性能。</p>
</li>
<li>
<p><code><span class="hljs-attribute">IntentService</span></code></p>
<p>这是 <code><span class="hljs-attribute">Service</span></code> 的子类，其使用工作线程逐一处理所有启动请求。</p>
<p>如果您不要求服务同时处理多个请求，此类为最佳选择。</p>
<p>实现 <code><span class="hljs-function"><span class="hljs-title">onHandleIntent</span><span class="hljs-params">()</span></span></code>，该方法会接收每个启动请求的 Intent，以便您执行后台工作。</p>
</li>
</ul>
<p>下文介绍如何使用其中任一类来实现服务。</p>
<h3>通过扩展 <code><span class="hljs-attribute">IntentService</span></code> 类创建服务</h3>
<p>由于大多数启动服务无需同时处理多个请求（实际上，这种多线程情况可能很危险），因此最佳选择是利用 <code><span class="hljs-attribute">IntentService</span></code> 类实现服务。</p>
<p><code><span class="hljs-attribute">IntentService</span></code> 类会执行以下操作：</p>
<ul>
<li>创建默认的工作线程，用于在应用的主线程外执行传递给 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 的所有 Intent。</li>
<li>创建工作队列，用于将 Intent 逐一传递给 <code><span class="hljs-function"><span class="hljs-title">onHandleIntent</span><span class="hljs-params">()</span></span></code> 实现，这样您就永远不必担心多线程问题。</li>
<li>在处理完所有启动请求后停止服务，因此您永远不必调用 <code><span class="hljs-function"><span class="hljs-title">stopSelf</span><span class="hljs-params">()</span></span></code>。</li>
<li>提供 <code><span class="hljs-function"><span class="hljs-title">onBind</span><span class="hljs-params">()</span></span></code> 的默认实现（返回 null）。</li>
<li>提供 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 的默认实现，可将 Intent 依次发送到工作队列和 <code><span class="hljs-function"><span class="hljs-title">onHandleIntent</span><span class="hljs-params">()</span></span></code> 实现。</li>
</ul>
<p>如要完成客户端提供的工作，请实现 <code><span class="hljs-function"><span class="hljs-title">onHandleIntent</span><span class="hljs-params">()</span></span></code>。不过，您还需为服务提供小型构造函数。</p>
<h3>通过扩展 <code><span class="hljs-attribute">Service</span></code> 类创建服务</h3>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">MyService</span> : <span class="hljs-symbol">Service</span>() {
	
}
</code></pre>
<p><code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code> 的返回值必须是以下常量之一，用于描述系统应如何在系统终止服务的情况下继续运行服务。：</p>
<ul>
<li>
<p><code><span class="hljs-attribute">START_NOT_STICKY</span></code></p>
<p>除非有待传递的挂起 Intent，否则系统<em>不会</em>重建服务。</p>
<p><font color="red">最安全</font></p>
</li>
<li>
<p><code><span class="hljs-attribute">START_STICKY</span></code></p>
<p>重建服务并调用 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code>，但<em>不会</em>重新传递最后一个 Intent。</p>
<p>除非有挂起 Intent 要启动服务，否则系统会调用包含空 Intent 的 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code>。</p>
<p><font color="red">此常量适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</font></p>
</li>
<li>
<p><code><span class="hljs-attribute">START_REDELIVER_INTENT</span></code></p>
<p>重建服务，并通过传递给服务的最后一个 Intent 调用 <code><span class="hljs-function"><span class="hljs-title">onStartCommand</span><span class="hljs-params">()</span></span></code>。</p>
<p><font color="red">适用于主动执行应立即恢复的作业（例如下载文件）的服务。</font></p>
</li>
</ul>
<p>如果您的应用面向 API 级别 26 或更高版本，除非应用本身在前台运行，否则系统不会对使用或创建后台服务施加限制。</p>
<p>如果应用需要创建前台服务，则其应调用 <code><span class="hljs-function"><span class="hljs-title">startForegroundService</span><span class="hljs-params">()</span></span></code>。</p>
<p>此方法会创建后台服务，但它会向系统发出信号，表明服务会将自行提升至前台。创建服务后，该服务必须在五秒内调用自己的 <code><span class="hljs-function"><span class="hljs-title">startForeground</span><span class="hljs-params">()</span></span></code> 方法。</p>

                </div>
            </article>
        </div>

    </div>
</div>
</body>
</html>
