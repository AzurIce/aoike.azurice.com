<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Aoike青池</title>

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://aoike.azurice.com/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<!--<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>-->

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    MC光影开发 —— 阴影篇（1）.md
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        修改于 · 2021-07-20 03:58:57 · 发布于 · 2021-09-23 07:16:50
                    </time>
                </div>
                <div class="post-content">
                    <h2>MC光影开发 —— 阴影篇（1）</h2>
<p><em>optifine/shadersmod</em> 提供给了我们一张日/月视角（视线始终指向玩家）的深度纹理图 <code><span class="hljs-attribute">shadow</span></code> ，利用这张纹理我们可以很方便地得到阴影的绘制方法。</p>
<p>![阴影_画板 1](V:_Posts\Halo\Minecraft\Shader\阴影篇.assets\阴影_画板 1.png)</p>
<p>对于一个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">P</span></span></span></span> ，若其与日/月间有物体，则应被涂上阴影。</p>
<p>考虑日/月光线为平行光，可以得到判断连线上有物体的依据为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="1.44em"><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>&lt;</mo><mi>d</mi></mstyle></mrow><annotation encoding="application/x-tex">\Large
depth &lt; d
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.9999935999999999em;"></span><span class="strut bottom" style="height:1.2799871999999999em;vertical-align:-0.2799936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="sizing reset-size5 size7 displaystyle textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mrel">&lt;</span><span class="mord mathit">d</span></span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">depth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">h</span></span></span></span> 则由 <code><span class="hljs-attribute">shadow</span></code> 纹理图得到，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 则很轻易地可以由点在日/月坐标系的位置得到。</p>
<h3>1. 求 d</h3>
<p>optifine/shadersmod提供给我们了关于日/月坐标系的相关变换矩阵：</p>
<pre><code class="hljs language-mermaid">graph
optifine/shadersmodModelCoord --shadowModelView--&gt; sunViewCoord
sunViewCoord --shadowModelViewInverse--&gt; optifine/shadersmodModelCoord
sunViewCoord --shadowProjection--&gt; sunClipCoord
sunClipCoord --shadowProjectionInverse--&gt; sunViewCoord
</code></pre>
<p>将裁剪坐标系进行透视除法，此时z坐标值即为该点到太阳的深度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 。</p>
<p>那么我们该怎么求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>h</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>M</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi><mi>C</mi><mi>o</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">optifine/shadersmodModelCoord</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathrm">/</span><span class="mord mathit">s</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span></span></span></span> 呢？要知道在 <code><span class="hljs-attribute">composite</span></code> 着色器中的 <code><span class="hljs-attribute">gl_Vertex</span></code> 为屏幕坐标（与 <code><span class="hljs-attribute">texcoord</span></code> 相同），经过 <code><span class="hljs-function"><span class="hljs-title">ftransform</span><span class="hljs-params">()</span></span></code> 得到的赋给 <code><span class="hljs-attribute">gl_Position</span></code> 的坐标为裁剪坐标，这二者均是缺少z轴信息的。不过好在<em>optifine/shadersmod</em> 提供了几张纹理图，存储了玩家视角的深度数据：</p>
<pre><code class="hljs language-glsl">	<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> depthtex0; <span class="hljs-comment">// 所有物体</span>
	<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> depthtex1; <span class="hljs-comment">// 除透明物体（水、染色玻璃）</span>
	<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> depthtex2; <span class="hljs-comment">// 除透明物体（水、染色玻璃）、手持物体</span>
</code></pre>
<p>![2021-07-06 12-14-57](V:_Posts\Halo\Minecraft\Shader\阴影篇.assets\2021-07-06 12-14-57.gif)</p>
<p>使用屏幕坐标的xy坐标，加上深度缓冲中的深度信息即可得到得到xyz信息齐全的NDC坐标，再进行一系列变换即可重建出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>h</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>M</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi><mi>C</mi><mi>o</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">optifine/shadersmodModelCoord</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathrm">/</span><span class="mord mathit">s</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span></span></span></span> ，流程如下图所示：<img src="V:_Posts%5CHalo%5CMinecraft%5CShader%5C%E9%98%B4%E5%BD%B1%E7%AF%87.assets%5C%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2-02.png" alt="坐标转换-02"></p>
<blockquote>
<p>经测试，在 vsh 中使用 <code>depthtex0</code> 纹理图无法得到有效的纹理数据，所以我们将这部分代码写在 fsh 中。</p>
</blockquote>
<p>首先基础部分：</p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// composite.vsh</span>
<span class="hljs-meta">#version 460 compatibility</span>

<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> texcoord;
<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> clipCoord;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();

    texcoord = <span class="hljs-built_in">gl_TextureMatrix</span>[<span class="hljs-number">0</span>] * <span class="hljs-built_in">gl_MultiTexCoord0</span>;
}
</code></pre>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// composite.fsh</span>
<span class="hljs-meta">#version 460 compatibility</span>

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gcolor;

<span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> texcoord;

<span class="hljs-comment">/* DRAWBUFFERS:0 */</span>

<span class="hljs-type">void</span> main() {
    <span class="hljs-type">vec4</span> color = <span class="hljs-built_in">texture2D</span>(gcolor, texcoord.st);
    
    <span class="hljs-built_in">gl_FragData</span>[<span class="hljs-number">0</span>] = color;
}
</code></pre>
<p>在 <code>composite.fsh</code> 中加入必要的变量声明：</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> gbufferModelViewInverse;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> gbufferProjectionInverse;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> shadowModelView;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> shadowProjection;

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> depthtex0;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> shadow;
</code></pre>
<p>在 <code>composite.fsh</code> 的 <code><span class="hljs-selector-tag">main</span></code> 函数中完成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>h</mi><mi>a</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>M</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi><mi>C</mi><mi>o</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">optifine/shadersmodModelCoord</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit">o</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">e</span><span class="mord mathrm">/</span><span class="mord mathit">s</span><span class="mord mathit">h</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">o</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">d</span></span></span></span> 重建：</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">float</span> depth = <span class="hljs-built_in">texture2D</span>(depthtex0, texcoord.st).x;

<span class="hljs-type">vec4</span> ndcCoord = <span class="hljs-type">vec4</span>(texcoord.st*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, depth*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);
<span class="hljs-type">vec4</span> clipCoord = gbufferProjectionInverse * ndcCoord;
<span class="hljs-type">vec4</span> viewCoord = clipCoord / clipCoord.w;
<span class="hljs-type">vec4</span> optfineCoord = gbufferModelViewInverse * viewCoord;
</code></pre>
<p>我们创建一个函数 <code><span class="hljs-attribute">addShader</span></code> ，并在其中实现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span></span></span></span> 的计算：</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">void</span> addShader(<span class="hljs-keyword">inout</span> <span class="hljs-type">vec4</span> color, <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> optifineCoord) {
	<span class="hljs-type">vec4</span> sunViewCoord = shadowModelView * optifineCoord;
    <span class="hljs-type">vec4</span> sunClipCoord = shadowProjection * sunViewCoord;
    <span class="hljs-type">vec4</span> sunNdcCoord = sunClipCoord / sunClipCoord.w;
    <span class="hljs-type">vec4</span> sunScreenCoord = sunNdcCoord * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;
    
    <span class="hljs-type">float</span> d = sunScreenCoord.z;
}
</code></pre>
<h3>2. 求depth</h3>
<p>日/月视角（视线始终指向玩家）的深度纹理图 <code><span class="hljs-attribute">shadow</span></code> ：</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> shadow;
</code></pre>
<p>从这张纹理中获取的颜色 rgb 均相同，表示离日/月最近的点到日/月的距离，纹理图始终以玩家为中心，随时间推移自动更新。</p>
<p>相当于是日/月视角（且视线注视着玩家）的深度图。</p>
<p>![2021-07-06 10-51-37 00_00_00-00_00_30](V:_Posts\Halo\Minecraft\Shader\阴影篇.assets\2021-07-06 10-51-37 00_00_00-00_00_30.gif)</p>
<p>那么很简单，就可以在 <code>composite.fsh</code> 的 <code><span class="hljs-attribute">addShader</span></code> 函数中继续完成对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">depth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">h</span></span></span></span> 的计算：</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">float</span> depth = <span class="hljs-built_in">texture2D</span>(shadow, sunScreenCoord.st).x;
</code></pre>
<p>注意获取纹理用的坐标为 日/月屏幕坐标。</p>
<h3>3. 完成判断并添加阴影</h3>
<p>继续完善 <code>composite.fsh</code> 中的 <code><span class="hljs-attribute">addShader</span></code> 函数：</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">if</span>(depth &lt; d) {
	color.rgb *= <span class="hljs-number">0.5</span>;
}
</code></pre>
<h4>完整代码小结</h4>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// composite.vsh</span>
<span class="hljs-meta">#version 460 compatibility</span>

<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> texcoord;
<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> clipCoord;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();

    texcoord = <span class="hljs-built_in">gl_TextureMatrix</span>[<span class="hljs-number">0</span>] * <span class="hljs-built_in">gl_MultiTexCoord0</span>;
}
</code></pre>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// composite.fsh</span>
<span class="hljs-meta">#version 460 compatibility</span>

<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> gbufferModelViewInverse;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> gbufferProjectionInverse;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> shadowModelView;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> shadowProjection;

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gcolor;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> depthtex0;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> shadow;

<span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> texcoord;

<span class="hljs-type">void</span> addShader(<span class="hljs-keyword">inout</span> <span class="hljs-type">vec4</span> color, <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> optifineCoord) {
	<span class="hljs-type">vec4</span> sunViewCoord = shadowModelView * optifineCoord;
    <span class="hljs-type">vec4</span> sunClipCoord = shadowProjection * sunViewCoord;
    <span class="hljs-type">vec4</span> sunNdcCoord = sunClipCoord / sunClipCoord.w;
    <span class="hljs-type">vec4</span> sunScreenCoord = sunNdcCoord * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;
    
    <span class="hljs-type">float</span> d = sunScreenCoord.z;
    <span class="hljs-type">float</span> depth = <span class="hljs-built_in">texture2D</span>(shadow, texcoord.st).x;
    
    <span class="hljs-keyword">if</span>(depth &lt; d) {
		color.rgb *= <span class="hljs-number">0.5</span>;
	}
}

<span class="hljs-comment">/* DRAWBUFFERS:0 */</span>

<span class="hljs-type">void</span> main() {
    <span class="hljs-type">float</span> depth = <span class="hljs-built_in">texture2D</span>(depthtex0, texcoord.st).x;

    <span class="hljs-type">vec4</span> ndcCoord = <span class="hljs-type">vec4</span>(texcoord.st*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, depth*<span class="hljs-number">2</span><span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-type">vec4</span> clipCoord = gbufferProjectionInverse * ndcCoord;
    <span class="hljs-type">vec4</span> viewCoord = clipCoord / clipCoord.w;
    <span class="hljs-type">vec4</span> optifineCoord = gbufferModelViewInverse * viewCoord;

    <span class="hljs-type">vec4</span> color = <span class="hljs-built_in">texture2D</span>(gcolor, texcoord.st);
    
    addShader(color, optifineCoord);
    
    <span class="hljs-built_in">gl_FragData</span>[<span class="hljs-number">0</span>] = color;
}
</code></pre>
<h3>4. 修复精度问题导致的阴间效果</h3>
<p>![2021-07-06 18-46-16](V:_Posts\Halo\Minecraft\Shader\阴影篇.assets\2021-07-06 18-46-16.gif)</p>
<p>这是由于浮点数精度不够产生的问题，有些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">depth = d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathit">h</span><span class="mrel">=</span><span class="mord mathit">d</span></span></span></span> 的点由于坐标转换等计算会丢失精度导致其值产生浮动，解决办法是加入一个小的误差允许值，取目标条件的一个不明显影响效果的子集：</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">if</span>(depth &lt; d - <span class="hljs-number">0.001</span>) {
	color.rgb *= <span class="hljs-number">0.5</span>;
}
</code></pre>
<p>![2021-07-06 18-50-17 00_00_00-00_00_30](V:_Posts\Halo\Minecraft\Shader\阴影篇.assets\2021-07-06 18-50-17 00_00_00-00_00_30.gif)</p>
<p>这样我们就修复了这个问题。</p>
<p>不过我们发现，这样子绘制出的阴影十分不精细，精细结构的阴影都是几坨黑块块在扭动，关于阴影精度的优化问题留到下一篇文章来讲解。</p>

                </div>
            </article>
        </div>

    </div>
</div>
</body>
</html>
