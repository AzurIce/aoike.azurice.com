<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Aoike青池</title>

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://aoike.azurice.com/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<!--<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>-->

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    2020-08-13-MCSHGo_note.md
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        修改于 · 2020-08-14 10:35:19 · 发布于 · 2021-09-23 07:11:35
                    </time>
                </div>
                <div class="post-content">
                    <hr>
<h2>layout: post<br>
title: MCSHGo - 开发笔记<br>
date: 2020-08-13<br>
tags: GoLang MCSH Minecraft</h2>
<h1>交叉编译</h1>
<pre><code class="hljs language-bash"><span class="hljs-built_in">set</span> GOOS=linux
go build -o MCSH-version main.go

<span class="hljs-built_in">set</span> GOOS=windows
go build -o MCSH-version.exe main.go
</code></pre>
<blockquote>
<p>set GOARCH=amd64</p>
</blockquote>
<h1>v0.1-alpha</h1>
<h2>一、配置文件相关部分</h2>
<h3>1. 结构</h3>
<ul>
<li>
<p>目录结构</p>
<pre><code class="hljs">MCSHGO/
│  config<span class="hljs-selector-class">.yml</span>
│  MCSHGo
│
└─Scripts/
        serverName1<span class="hljs-selector-class">.bat</span>
        serverName2<span class="hljs-selector-class">.bat</span>
        ...
</code></pre>
</li>
<li>
<p>配置文件 <code>config.yml</code> ：</p>
<pre><code class="hljs language-Yaml"><span class="hljs-attr">servers:</span>
	<span class="hljs-attr">serverName1:</span>
		<span class="hljs-attr">rootFolder:</span> <span class="hljs-string">path/to/your/server/root/folder</span>
        <span class="hljs-attr">scriptFile:</span> <span class="hljs-string">script_file_name.xx</span>
    <span class="hljs-attr">serverName2:</span>
		<span class="hljs-attr">rootFolder:</span> <span class="hljs-string">path/to/your/server/root/folder</span>
        <span class="hljs-attr">scriptFile:</span> <span class="hljs-string">script_file_name.xx</span>
    <span class="hljs-string">......</span>
</code></pre>
<blockquote>
<p>所有服务器的 <code><span class="hljs-attribute">scriptFile</span></code> 均存放于 <code><span class="hljs-variable"><span class="hljs-class">Scripts</span></span>/</code> 中</p>
</blockquote>
</li>
<li>
<p>结构体</p>
<pre><code class="hljs language-go">{% raw %}
<span class="hljs-comment">// 对应config.yml</span>
<span class="hljs-keyword">type</span> structMCSHConfig <span class="hljs-keyword">struct</span> {
	Servers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]structServerConfig <span class="hljs-string">`yaml:&quot;servers&quot;`</span>
}
</code></pre>
</li>
</ul>
<p>{% endraw %}<br>
```</p>
<pre><code class="hljs">```go
{% raw %}
// 对应servers中的元素
type structServerConfig struct {
	RootFolder string `yaml:&quot;rootFolder&quot;`
	ScriptFile string `yaml:&quot;scriptFile&quot;`
}
{% endraw %}
```
</code></pre>
<h2>2. 配置文件读取</h2>
<h3><code><span class="hljs-built_in">io</span>/ioutil</code></h3>
<ul>
<li>
<p><code><span class="hljs-function"><span class="hljs-title">ReadFile</span><span class="hljs-params">(filename string)</span></span> (<span class="hljs-selector-attr">[]</span>byte, error)</code></p>
<p>从 <strong>filename</strong> 指定文件中读取数据并以 <code>[<span class="hljs-meta"></span>]<span class="hljs-built_in">byte</span></code> 类型返回内容。</p>
<p>若成功调用，返回的 <strong>err</strong> 为 <strong>nil</strong></p>
</li>
<li>
<p><code><span class="hljs-constructor">WriteFile(<span class="hljs-params">filename</span> <span class="hljs-params">string</span>, <span class="hljs-params">data</span> []<span class="hljs-params">byte</span>, <span class="hljs-params">perm</span> <span class="hljs-params">os</span>.FileMode)</span> error</code></p>
<p>将 <strong>filename</strong> 指定文件清空，并向其中写入 <strong>data</strong> 。</p>
<p>若文件不存在，则按照 <strong>perm</strong> 给出的权限创建文件。</p>
<blockquote>
<p>linux文件权限系统中有三种可以拥有的访问权限：</p>
<p><strong>r</strong> 可读， <strong>w</strong> 可写， <strong>x</strong> 可执行</p>
<p>分别对应 4， 2， 1，分别为 1&lt;&lt;2, 1&lt;&lt;1, 1&lt;&lt;0 三个二进制位</p>
<p>每个文件有4个权限位： 特殊权限位，拥有者位，同组用户位，其余用户位</p>
<p>所以每一个文件的权限可以用4个八进制数来表示，一般特殊权限位为0。</p>
</blockquote>
<blockquote>
<p>例：拥有者、同组用户、其余用户 可读可写： (0)(2+4)(2+4)(2+4) = 0666</p>
</blockquote>
</li>
</ul>
<h3><code><span class="hljs-attribute">os</span></code></h3>
<ul>
<li>
<p><code>func <span class="hljs-constructor">IsNotExist(<span class="hljs-params">err</span> <span class="hljs-params">error</span>)</span> <span class="hljs-built_in">bool</span></code></p>
<p>判断 <code><span class="hljs-attribute">err</span></code> 是否表示一个文件或目录不存在（ErrNotExist和一些系统调用错误）。</p>
</li>
<li>
<p><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Exit</span><span class="hljs-params">(code <span class="hljs-keyword">int</span>)</span></span></code></p>
<p>以状态码 <code><span class="hljs-keyword">code</span></code> 退出程序</p>
</li>
</ul>
<h3><a href="https://github.com/go-yaml/yaml"><code><span class="hljs-attribute">gopkg</span>.in/yaml.v<span class="hljs-number">3</span></code></a></h3>
<ul>
<li>
<p><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(in <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-params">(out []<span class="hljs-keyword">byte</span>, err error)</span></span></code></p>
<blockquote>
<p>输入 map/指针 转为 YAML []byte</p>
</blockquote>
<p>结构体中的字段标记：</p>
<pre><code class="hljs language-go"><span class="hljs-string">`(...) yaml:&quot;[&lt;key&gt;][,&lt;flag1&gt;[,&lt;flag2&gt;]]&quot; (...)`</span>
</code></pre>
<p>flag：</p>
<ul>
<li><strong>omitempty</strong> 只有当非零值或空的slice/map是才包含该字段</li>
<li><strong>flow</strong> 用 flow 样式进行 Marshal（对于结构体、序列、map很有用）</li>
<li><strong>inline</strong> Inline the field, which must be a struct or a map,<br>
causing all of its fields or keys to be processed as if<br>
they were part of the outer struct. For maps, keys must<br>
not conflict with the yaml keys of other struct fields.</li>
</ul>
</li>
<li>
<p><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(in []<span class="hljs-keyword">byte</span>, out <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-params">(err error)</span></span></code></p>
<blockquote>
<p>输入 Yaml []byte，转为map/指针</p>
</blockquote>
</li>
</ul>
<h3>CODE</h3>
<pre><code class="hljs language-go">{% raw %}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readConfig</span><span class="hljs-params">()</span></span> {
	configYaml, err := ioutil.ReadFile(<span class="hljs-string">&quot;./config.yml&quot;</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> { <span class="hljs-comment">// 读取文件发生错误</span>
		<span class="hljs-keyword">if</span> os.IsNotExist(err) { <span class="hljs-comment">// 文件不存在，创建并写入默认配置</span>
			log.Println(<span class="hljs-string">&quot;MCSH: Cannot find config.yml, creating...&quot;</span>)
			ioutil.WriteFile(<span class="hljs-string">&quot;./config.yml&quot;</span>, data2yaml(mcshConfig), <span class="hljs-number">0666</span>)
			log.Println(<span class="hljs-string">&quot;MCSH: Successful created config.yml, please complete the config.&quot;</span>)
			os.Exit(<span class="hljs-number">1</span>) <span class="hljs-comment">//退出，提示完成config</span>
		}
		fmt.Println(err) <span class="hljs-comment">// 不是因为文件不存在而报错，输出并退出</span>
		os.Exit(<span class="hljs-number">1</span>)
	}
	mcshConfig = structMCSHConfig{}
	err = yaml.Unmarshal(configYaml, &amp;mcshConfig) <span class="hljs-comment">// 解析Yaml</span>
}
{% endraw %}
</code></pre>
<h2>3. 启动服务器</h2>
<pre><code class="hljs language-go">{% raw %}
<span class="hljs-keyword">for</span> name, serverConfig := <span class="hljs-keyword">range</span> mcshConfig.Servers {
		<span class="hljs-keyword">go</span> runServer(name, serverConfig, writeClosers)
		wg.Add(<span class="hljs-number">1</span>)
	}
	<span class="hljs-keyword">go</span> asyncForwardStdin()
	wg.Wait()
{% endraw %}
</code></pre>
<p>遍历 <code>mcshConfig.Servers</code> 中的每一个服务器，启动一个协程来 <code><span class="hljs-attribute">runServer</span></code> ，将其 <code>stdin</code> 存入全局 <code><span class="hljs-string">[]</span>io.WriteCloser</code> 中，并在其中用两个协程分别启动对应 <code>stdout</code> 、 <code>stderr</code> 的转发。</p>
<p>随后在主线程中新开一协程来处理输入，<code>serverName<span class="hljs-string">|xxx</span></code> 将 <code><span class="hljs-attribute">xxx</span></code> 写入对应服务器 <code>stdin</code></p>
<pre><code class="hljs language-go">{% raw %}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runServer</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, serverConfig structServerConfig, writeClosers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]io.WriteCloser)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">if</span> err := os.Chdir(serverConfig.RootFolder); err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">if</span> os.IsNotExist(err) {
			log.Printf(<span class="hljs-string">&quot;server&lt;%s&gt;: Cannot find server root folder, please check your \&quot;config.yml\&quot;&quot;</span>, name)
			wg.Done()
			<span class="hljs-keyword">return</span> err
		}
		log.Printf(<span class="hljs-string">&quot;server&lt;%s&gt;: Error when chdir to server root folder - %s&quot;</span>, name, err.Error())
		wg.Done()
		<span class="hljs-keyword">return</span> err
	}
	cmd := exec.Command(path.Join(wd, <span class="hljs-string">&quot;Scripts&quot;</span>, serverConfig.ScriptFile))

	writeClosers[name], _ = cmd.StdinPipe()
	stdout, _ := cmd.StdoutPipe()
	stderr, _ := cmd.StderrPipe()

	<span class="hljs-keyword">if</span> err := cmd.Start(); err != <span class="hljs-literal">nil</span> {
		log.Printf(<span class="hljs-string">&quot;server&lt;%s&gt;: Error when starting: %s......&quot;</span>, name, err.Error())
		wg.Done()
		<span class="hljs-keyword">return</span> err
	}
	<span class="hljs-keyword">go</span> asyncLog(name, stdout)
	<span class="hljs-keyword">go</span> asyncLog(name, stderr)

	<span class="hljs-keyword">if</span> err := cmd.Wait(); err != <span class="hljs-literal">nil</span> {
		log.Printf(<span class="hljs-string">&quot;server&lt;%s&gt;: Error running: %s......&quot;</span>, name, err.Error())
		wg.Done()
		<span class="hljs-keyword">return</span> err
	}
	wg.Done()
	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
{% endraw %}
</code></pre>
<h4>IO转发</h4>
<pre><code class="hljs language-go">{% raw %}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncLog</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, readCloser io.ReadCloser)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">var</span> outputReplaceRegString = <span class="hljs-string">`(\[\d\d:\d\d:\d\d\]) *\[.+?\/(.+?)\]`</span>
	outputReplaceReg, err := regexp.Compile(outputReplaceRegString)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Println(<span class="hljs-string">&quot;MCSH[outputForward/ERROR]: Regex compile failed - &quot;</span>, err)
	}
	cache := <span class="hljs-string">&quot;&quot;</span>
	buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1024</span>)
	<span class="hljs-keyword">for</span> {
		num, err := readCloser.Read(buf)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; err != io.EOF {
			<span class="hljs-keyword">return</span> err
		}
		<span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span> {
			<span class="hljs-comment">// b := buf[:num]</span>
			s := outputReplaceReg.ReplaceAllString(<span class="hljs-keyword">string</span>(buf[:num]), <span class="hljs-string">&quot;[&quot;</span>+name+<span class="hljs-string">&quot;/$2]&quot;</span>)
			lines := strings.Split(s, <span class="hljs-string">&quot;\n&quot;</span>)
			lines[<span class="hljs-number">0</span>] = cache + lines[<span class="hljs-number">0</span>]
			<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(lines)<span class="hljs-number">-1</span>; i++ {
				log.Println(lines[i])
			}
			cache = lines[<span class="hljs-built_in">len</span>(lines)<span class="hljs-number">-1</span>]
		}
	}
}
{% endraw %}
</code></pre>
<pre><code class="hljs language-go">{% raw %}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncForwardStdin</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> forwardRegString = <span class="hljs-string">`(.+?) *\| *(.+)`</span>
	forwardReg, errCompile := regexp.Compile(forwardRegString)
	<span class="hljs-keyword">if</span> errCompile != <span class="hljs-literal">nil</span> {
		log.Println(<span class="hljs-string">&quot;MCSH[stdinForward/ERROR]: Regex compile failed - &quot;</span>, errCompile)
	}

	stdinReader := bufio.NewReader(os.Stdin)
	<span class="hljs-keyword">for</span> {
		line, errRead := stdinReader.ReadBytes(<span class="hljs-string">&#x27;\n&#x27;</span>)
		<span class="hljs-keyword">if</span> errRead != <span class="hljs-literal">nil</span> {
			log.Println(<span class="hljs-string">&quot;MCSH[stdinForward/ERROR]: &quot;</span>, errRead)
		} <span class="hljs-keyword">else</span> {
			line = line[:<span class="hljs-built_in">len</span>(line)<span class="hljs-number">-1</span>]
			<span class="hljs-keyword">if</span> line[<span class="hljs-built_in">len</span>(line)<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;\r&#x27;</span> {
				line = line[:<span class="hljs-built_in">len</span>(line)<span class="hljs-number">-1</span>]
			}
			<span class="hljs-comment">// log.Println(line)</span>
			res := forwardReg.FindSubmatch(line)
			<span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> {
				<span class="hljs-comment">// log.Println(res)</span>
				_, valid := writeClosers[<span class="hljs-keyword">string</span>(res[<span class="hljs-number">1</span>])]
				<span class="hljs-keyword">if</span> valid {
					_, errWrite := writeClosers[<span class="hljs-keyword">string</span>(res[<span class="hljs-number">1</span>])].Write(<span class="hljs-built_in">append</span>(res[<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;\n&#x27;</span>))
					<span class="hljs-keyword">if</span> errWrite != <span class="hljs-literal">nil</span> {
						log.Println(<span class="hljs-string">&quot;MCSH[stdinForward/ERROR]: Server stdin write failed - &quot;</span>, errWrite)
					}
				} <span class="hljs-keyword">else</span> {
					log.Printf(<span class="hljs-string">&quot;MCSH[stdinForward/ERROR]: Cannot find running server &lt;%v&gt;\n&quot;</span>, <span class="hljs-keyword">string</span>(res[<span class="hljs-number">1</span>]))
				}
			}
		}
	}
}
{% endraw %}
</code></pre>
<h1>v0.2-alpha</h1>
<h3><code>os/<span class="hljs-built_in">exec</span></code></h3>
<ul>
<li>
<p><code><span class="hljs-function"><span class="hljs-title">Command</span><span class="hljs-params">()</span></span></code></p>
<blockquote>
<p>要完成文件后缀</p>
</blockquote>
<blockquote>
<p>linux下直接写脚本的文件名时，需要让脚本满足sh脚本语法</p>
<p>且需要chmod +x</p>
<p>否则需要 使用 <code><span class="hljs-function"><span class="hljs-title">Command</span><span class="hljs-params">(<span class="hljs-string">&quot;bash&quot;</span>, scriptFileName)</span></span></code> 才不会在 <code><span class="hljs-built_in">cmd</span>.<span class="hljs-built_in">start</span>()</code> 时Panic</p>
</blockquote>
</li>
</ul>

                </div>
            </article>
        </div>

    </div>
</div>
</body>
</html>
