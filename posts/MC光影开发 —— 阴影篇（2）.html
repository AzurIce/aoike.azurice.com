<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Aoike青池</title>

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://aoike.azurice.com/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<!--<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>-->
<!--<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>-->

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    MC光影开发 —— 阴影篇（2）.md
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        修改于 · 2021-07-09 05:24:38 · 发布于 · 2021-09-23 07:12:32
                    </time>
                </div>
                <div class="post-content">
                    <h2>MC 光影开发 —— 阴影篇（2）</h2>
<p>上次完成了基础的阴影绘制，但绘制出的阴影精度不佳，这一篇我们主要来优化阴影的效果。</p>
<h3>精度提高 —— 设置shadow纹理的分辨率</h3>
<p>shadow纹理的分辨率默认是 1024，我们可以在 <code>composite.fsh</code> 中加入下面一行来设置为更高的分辨率。</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> shadowMapResolution = <span class="hljs-number">4096</span>;
</code></pre>
<p>当分辨率分别设为 1024, 2048, 4096, 8192, 16384, 32768 时效果分别如下：</p>
<p>![1024](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\1024.gif)</p>
<p>![2048](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\2048.gif)</p>
<p>![4096](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\4096.gif)</p>
<p>![8192](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\8192.gif)</p>
<p>![16384](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\16384.gif)</p>
<p>![32768](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\32768.gif)</p>
<p>然而一味地增大shadow纹理分辨率并不是可取的办法，不仅会消耗大量性能，当分辨率过高时还会导致下列问题：</p>
<p>![image-20210708173236724](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\image-20210708173236724.png)</p>
<p>那么我们在有限的分辨率内能否再进一步提升精度呢？</p>
<h3>精度提高 —— 鱼眼镜头采样</h3>
<p>我们引入了鱼眼镜头来采样shadow纹理，其基本想法是：玩家始终位于shaodw纹理中心，游戏中玩家对远处物体细节关注程度也往往小于进处，那么我们可以通过增加近处的采样点，减少远处的采样点来在统一分辨率下做出更好地效果。</p>
<p><img src="V:\_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\2021-07-08_17.44.07.png" alt="2021-07-08_17.44.07" style="zoom:12%;" /><img src="V:\_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\2021-07-08_17.44.43.png" alt="2021-07-08_17.44.43" style="zoom:12%;" /></p>
<p>如上图，在最终得到的shadow纹理分辨率相同的情况下，后者的shadow纹理距玩家近处的采样点、细节更多，而远处更少。</p>
<p>如何实现呢？我们创建 <code><span class="hljs-built_in">shadow</span>.vsh</code> 和 <code><span class="hljs-built_in">shadow</span>.fsh</code> ，并向其中写入基础代码：</p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// shadow.vsh</span>
<span class="hljs-meta">#version 460 compatibility</span>

<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> texcoord;

<span class="hljs-type">void</span> main() {
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();

    texcoord = <span class="hljs-built_in">gl_TextureMatrix</span>[<span class="hljs-number">0</span>] * <span class="hljs-built_in">gl_MultiTexCoord0</span>;
}
</code></pre>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// shadow.fsh</span>
<span class="hljs-meta">#version 460 compatibility</span>

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> <span class="hljs-built_in">texture</span>;
<span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> texcoord;

<span class="hljs-type">void</span> main() {
    <span class="hljs-type">vec4</span> color = <span class="hljs-built_in">texture2D</span>(<span class="hljs-built_in">texture</span>, texcoord.st);
    
    <span class="hljs-built_in">gl_FragData</span>[<span class="hljs-number">0</span>] = color;
}
</code></pre>
<p><code><span class="hljs-attribute">shadow</span></code> 的顶点着色器的输出 <code><span class="hljs-attribute">gl_Position</span></code> 是该像素对应在屏幕上的 ndc 坐标，着色器的输出 <code><span class="hljs-attribute">gl_FragData</span>[<span class="hljs-number">0</span>]</code> 即是将来该像素的颜色。以此产生将来的 <code><span class="hljs-attribute">shadow</span></code> 纹理。</p>
<p>那么我们想要达成鱼眼效果，即要将所有点按不同程度远离原点一些。</p>
<p>![鱼眼镜头-04](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\鱼眼镜头-04.png)</p>
<p>最后我们在 <code><span class="hljs-built_in">shadow</span>.vsh</code> 和 <code>composite.fsh</code> 中加入鱼眼效果代码：（也可以单独写在一个 <code>util.glsl</code> 文件中后借助 <code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;util.glsl&quot;</span></span></code> 来引入）</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec2</span> getFishEyeCoord(<span class="hljs-type">vec2</span> posInNDCCoord) {
    <span class="hljs-keyword">return</span> posInNDCCoord / (<span class="hljs-number">0.15</span> + <span class="hljs-number">0.85</span>*<span class="hljs-built_in">length</span>(posInNDCCoord.xy));
}
</code></pre>
<p>并在 <code><span class="hljs-built_in">shadow</span>.vsh</code> 和 <code>composite.fsh</code> 中调用，分别完成对纹理采样位置和日/月ndc坐标的变换使之仍能一一对应：</p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// shadow.vsh 中加入</span>
<span class="hljs-built_in">gl_Position</span>.xy = getFishEyeCoord(<span class="hljs-built_in">gl_Position</span>.xy);
</code></pre>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// composite.fsh 中加入</span>
sunNdcCoord.xy = getFishEyeCoord(sunNdcCoord.xy);
</code></pre>
<p>完成后可以发现，在 4096 的shader纹理分辨率下也可以显示较为完整的阴影细节：</p>
<p>![2021-07-08 21-54-16](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\2021-07-08 21-54-16.gif)</p>
<p>不过我们发现在与日/月光线平行的方块侧表面会产生奇妙的阴影，这也是浮点误差导致，我们可以借助像素位置的法线来进行特判予以解决。</p>
<p>![2021-07-08_22.02.15](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\2021-07-08_22.02.15.png)</p>
<h3>平行与光线的表面的特判 —— 法线</h3>
<p><font color="red">有时间重新整理！！！</font></p>
<p>为了让 <code><span class="hljs-attribute">composite</span></code> 着色器可以使用法线数据，我们需要在所有 <code><span class="hljs-attribute">gbuffers</span></code> 着色器中启用 <code><span class="hljs-attribute">gl_FragData</span>[<span class="hljs-number">1</span>]</code> 来传递法线数据。</p>
<blockquote>
<p><code><span class="hljs-attribute">gbuffers</span></code> 阶段向 <code><span class="hljs-attribute">gl_FragData</span></code> 中输入的数据会成为 <code><span class="hljs-attribute">composite</span></code> 阶段的纹理</p>
<p>更详细的内容见：<a href="http://blog.hakugyokurou.net/?p=1364">如何编写Shadersmod光影包(上) | 白玉楼之梦 (hakugyokurou.net)</a></p>
</blockquote>
<ol>
<li>
<p>在 <code>composite.fsh</code> 中完成对 <code><span class="hljs-attribute">gnormal</span></code> 格式的声明</p>
<pre><code class="hljs language-glsl"><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> RGB32F = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-type">int</span> gnormalFormat = RGB32F;
</code></pre>
</li>
<li>
<p>向所有 <code><span class="hljs-attribute">gbuffers</span></code> 着色器中声明变量，用以传递法线数据</p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">// vsh</span>
<span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> normal;
<span class="hljs-comment">// vsh main</span>
normal = <span class="hljs-built_in">gl_NormalMatrix</span> * <span class="hljs-built_in">gl_Normal</span>;
<span class="hljs-comment">// fsh</span>
<span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> normal;
</code></pre>
</li>
<li>
<p>在所有 <code><span class="hljs-attribute">gbuffers</span></code> 片段着色器中声明缓冲输出</p>
<pre><code class="hljs language-glsl"><span class="hljs-comment">/* DRAWBUFFERS:02 */</span>
</code></pre>
</li>
<li>
<p>在所有 <code><span class="hljs-attribute">gbuffers</span></code> 片段着色器的 <code><span class="hljs-selector-tag">main</span></code> 函数中输出法线数据到缓冲区</p>
<pre><code class="hljs language-glsl"><span class="hljs-built_in">gl_FragData</span>[<span class="hljs-number">1</span>] = <span class="hljs-type">vec4</span>(normal, <span class="hljs-number">1.0</span>);
</code></pre>
</li>
<li>
<p>在 <code><span class="hljs-attribute">composite</span></code> 中可以以纹理的形式使用，就像gcolor。我们向 <code>composite.fsh</code> 的 <code><span class="hljs-attribute">addShader</span></code> 函数中加入特判.</p>
<pre><code class="hljs language-glsl"><span class="hljs-type">vec3</span> normalInWorldCoord = <span class="hljs-built_in">texture2D</span>(gnormal, texcoord.st).xyz;
<span class="hljs-type">vec3</span> shadowLightPosInWorldCoord = (gbufferModelViewInverse * <span class="hljs-type">vec4</span>(shadowLightPosition, <span class="hljs-number">1</span>)).xyz;
<span class="hljs-type">float</span> dotans = <span class="hljs-built_in">dot</span>(<span class="hljs-built_in">normalize</span>(normalInWorldCoord), <span class="hljs-built_in">normalize</span>(shadowLightPosInWorldCoord));

<span class="hljs-comment">// 平面背对（&lt; 0）或 平行（= 0）于光线直接涂黑（误差允许范围内+=0.1）</span>
<span class="hljs-keyword">if</span>(dotans &lt; <span class="hljs-number">0.1</span>) {
    color.rgb *= <span class="hljs-number">0.5</span>;
    <span class="hljs-keyword">return</span>;
}
</code></pre>
<p>修复后效果：</p>
<p>![特判](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\特判.gif)</p>
</li>
</ol>
<h3>距离判断 —— 修复被错误染黑的天空</h3>
<p>借助 optifine/shadersmod 提供的变量 <code><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> far</code> （表示当前视距下最远距离）来计算待绘制点的距离，距离越远则强度越低、淡出：</p>
<pre><code class="hljs language-glsl">![距离判断](V:\_Posts\Halo\Minecraft\Shader\距离判断.giffloat shadowStrength = factor * (<span class="hljs-number">1</span> - <span class="hljs-built_in">length</span>(optifineCoord) / far);
</code></pre>
<p>可以使用一个变量factor来作为系数调整强度。</p>
<p>将涂阴影（修改color）部分代码改为</p>
<pre><code class="hljs language-glsl">color.rgb *= <span class="hljs-number">0.5</span> * shadowStrength + (<span class="hljs-number">1</span> - shadowStrength);
</code></pre>
<p>并加入条件判断，只有当 shadowStrength&gt;0时才绘制阴影。</p>
<p>![距离判断](V:_Posts\Halo\Minecraft\Shader\MC光影开发 —— 阴影篇（2）.assets\距离判断.gif)</p>
<h3>软阴影 —— 高斯模糊</h3>
<p>咕</p>

                </div>
            </article>
        </div>

    </div>
</div>
</body>
</html>
